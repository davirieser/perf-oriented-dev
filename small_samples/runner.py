
import math
import sys
import time
import json
import subprocess

programs = [
    # Arg 0 = Delannoy Number between 0 and 22.
    { "name": "delannoy", "args": [ "12" ] },
    # Arg 0 = Number of Directories to generate.
    # Arg 1 = Number of Files per Directory.
    # Arg 2 = Minimum File Size.
    # Arg 3 = Maximum File Size.
    # Arg 4 (optional) = RNG Seed.
    { "name": "filegen", "args": [ "5", "25", "1024000", "2048000" ] },
    # No Args
    { "name": "filesearch", "args": [] },
    # No Args
    { "name": "mmul", "args": [] },
    # No Args
    { "name": "nbody", "args": [] },
    # Arg 0 = Problem File to solve.
    { "name": "qap", "args": [ "qap/problems/chr15b.dat" ] },
]

# NOTE: This function was generated by ChatGPT
def parse_key_value_pairs(output):
    key_value_pairs = output.splitlines()
    key_value_map = {}

    for pair in key_value_pairs:
        if ':' in pair:
            key, value = pair.split(':', 1)
            key = key.strip()
            value = float(value.strip())
            key_value_map[key] = value

    return key_value_map

metrics = [ 
    { 
        "name": "Real Time", 
        "fmt-string": "%e", 
    },
    {
        "name": "User Time",
        "fmt-string": "%U",
    },
    {
        "name": "System Time",
        "fmt-string": "%S",
    },
    {
        "name": "Max. Memory",
        "fmt-string": "%M",
    }
]
time_format_string = '\n'.join([f"{metric['name']}:{metric['fmt-string']}" for metric in metrics])

def measure_program(program):
    result = subprocess.run(["/bin/time", f"-f {time_format_string}", f"build/{program['name']}"] + program["args"], capture_output=True)

    success = result.returncode == 0

    program_output = result.stdout.decode("utf-8")
    time_output = result.stderr.decode("utf-8")

    if (success):
        metrics = parse_key_value_pairs(time_output)
    else:
        metrics = {}

    return { "success": success, "metrics": metrics, "output": program_output }

if __name__ == "__main__":
    if (len(sys.argv) > 1):
        repetitions = int(sys.argv[1])
        if (repetitions < 1):
            print("Repetitions has to be greater or equal 1")
            sys.exit(-1)
    else:
        repetitions = 1
    
    results = []
    for program in programs:
        time_stamp = time.strftime("%H:%M:%S %d.%m.%Y", time.localtime())

        print(f"Running Program \"{program['name']}\" {repetitions} times: ", end='')

        fails = []
        program_results = []

        for i in range(repetitions): 
            print(f"{i}{'..' if i < (repetitions - 1) else ''}", end='', flush=True)
            result = measure_program(program)
            if (not result["success"]):
                fails.append(i)
            else:
                program_results.append(result)

        print()
        if (len(fails) > 0):
            print(f"Runs {fails} failed!")

        if(len(program_results) > 0):
            mean = { metric["name"]: sum([p_result["metrics"][metric["name"]] for p_result in program_results]) / len(program_results) for metric in metrics }
            squared_differences = { metric["name"] : sum([pow(p_result["metrics"][metric["name"]] - mean[metric["name"]], 2) for p_result in program_results]) for metric in metrics }
            variance = { metric["name"] : squared_differences[metric["name"]] / (len(program_results) - 1) for metric in metrics }
            standard_deviation = { metric["name"]: math.sqrt(variance[metric["name"]]) for metric in metrics }
            outputs = { f"output[{idx}]": p_result["output"] for idx, p_result in enumerate(program_results) }

            results.append(program | { "repetitions": repetitions, "outputs": outputs, "squared_differences": squared_differences, "standard_deviation": standard_deviation, "variance": variance, "mean": mean, "time_stamp": time_stamp })

    json_dumps = [ json.dumps(result, indent=4, skipkeys=True) + '\n' for result in results ]
    with open("results.json", 'a+') as f:
        f.writelines(json_dumps)
        f.write('\n')


